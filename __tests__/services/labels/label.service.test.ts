import { AxiosError } from 'axios';
import { createRequestWithEntity } from '@/lib/axios';
import { Label, GenerateLabelRequest } from '@/services/labels/labels.service';

// Mock del módulo axios
jest.mock('@/lib/axios', () => ({
  createRequestWithEntity: jest.fn(),
}));

const mockAxiosInstance = {
  get: jest.fn(),
  post: jest.fn(),
  patch: jest.fn(),
  delete: jest.fn(),
};

(createRequestWithEntity as jest.Mock).mockReturnValue(mockAxiosInstance);

// IMPORTAR DESPUÉS de haber mockeado
let labelsService: typeof import('@/services/labels/labels.service').labelsService;

beforeAll(() => {
  (require('@/lib/axios').createRequestWithEntity as jest.Mock).mockReturnValue(mockAxiosInstance);
  labelsService = require('@/services/labels/labels.service').labelsService;
});

describe('LabelsService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Mock data
  const mockContainer = {
    id: 'container-1',
    name: 'Glass Container'
  };

  const mockTemplateLabel: Label = {
    id: 'label-1',
    name: 'Classic Template',
    description: 'A classic label template',
    imageUrl: 'https://example.com/template.jpg',
    type: 'template' as const,
    isActive: true,
    container: mockContainer,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z'
  };

  const mockAILabel: Label = {
    id: 'label-2',
    name: 'AI Generated Label',
    description: 'Generated by AI',
    imageUrl: 'https://example.com/ai-label.jpg',
    type: 'ai-generated' as const,
    aiPrompt: 'Create a minimalist label with floral elements',
    isActive: true,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z'
  };

  const mockCustomLabel: Label = {
    id: 'label-3',
    name: 'Custom Upload',
    description: 'User uploaded custom label',
    imageUrl: 'https://example.com/custom.jpg',
    type: 'custom' as const,
    isActive: true,
    container: mockContainer,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z'
  };

  const mockLocalLabel: Label = {
    id: 'local-1',
    name: 'Local Label',
    description: 'Local preview label',
    imageUrl: '',
    type: 'custom' as const,
    isActive: true,
    isLocal: true,
    localPreview: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABA...',
    localPrompt: 'Test prompt',
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z'
  };

  const mockFile = new File(['test content'], 'test-label.jpg', { type: 'image/jpeg' });

  describe('getAllLabels', () => {
    it('should fetch all labels successfully', async () => {
      const mockLabels = [mockTemplateLabel, mockAILabel, mockCustomLabel];
      mockAxiosInstance.get.mockResolvedValue({ data: mockLabels });

      const result = await labelsService.getAllLabels();

      expect(mockAxiosInstance.get).toHaveBeenCalledWith('/labels');
      expect(result).toEqual(mockLabels);
      expect(result).toHaveLength(3);
    });

    it('should handle empty response', async () => {
      mockAxiosInstance.get.mockResolvedValue({ data: [] });

      const result = await labelsService.getAllLabels();

      expect(mockAxiosInstance.get).toHaveBeenCalledWith('/labels');
      expect(result).toEqual([]);
      expect(result).toHaveLength(0);
    });

    it('should handle API error when fetching all labels', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 503,
        data: { message: 'Service unavailable' },
        statusText: 'Service Unavailable',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.get.mockRejectedValue(axiosError);

      await expect(labelsService.getAllLabels()).rejects.toThrow();
    });
  });

  describe('getTemplateLabels', () => {
    it('should fetch template labels successfully', async () => {
      const mockTemplateLabels = [mockTemplateLabel];
      mockAxiosInstance.get.mockResolvedValue({ data: mockTemplateLabels });

      const result = await labelsService.getTemplateLabels();

      expect(mockAxiosInstance.get).toHaveBeenCalledWith('/labels/templates');
      expect(result).toEqual(mockTemplateLabels);
      expect(result[0].type).toBe('template');
    });

    it('should handle error when fetching template labels', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 400,
        data: { message: 'Bad request' },
        statusText: 'Bad Request',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.get.mockRejectedValue(axiosError);

      await expect(labelsService.getTemplateLabels()).rejects.toThrow();
    });
  });

  describe('getLabelsByContainer', () => {
    it('should fetch labels by container successfully', async () => {
      const mockContainerLabels = [mockTemplateLabel, mockCustomLabel];
      mockAxiosInstance.get.mockResolvedValue({ data: mockContainerLabels });

      const result = await labelsService.getLabelsByContainer('container-1');

      expect(mockAxiosInstance.get).toHaveBeenCalledWith('/labels/container/container-1');
      expect(result).toEqual(mockContainerLabels);
      expect(result.every(label => label.container?.id === 'container-1')).toBe(true);
    });

    it('should handle empty container labels', async () => {
      mockAxiosInstance.get.mockResolvedValue({ data: [] });

      const result = await labelsService.getLabelsByContainer('container-1');

      expect(mockAxiosInstance.get).toHaveBeenCalledWith('/labels/container/container-1');
      expect(result).toEqual([]);
    });

    it('should handle container not found error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 404,
        data: { message: 'Container not found' },
        statusText: 'Not Found',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.get.mockRejectedValue(axiosError);

      await expect(labelsService.getLabelsByContainer('nonexistent')).rejects.toThrow();
    });
  });

  describe('getLabelById', () => {
    it('should fetch label by ID successfully', async () => {
      mockAxiosInstance.get.mockResolvedValue({ data: mockTemplateLabel });

      const result = await labelsService.getLabelById('label-1');

      expect(mockAxiosInstance.get).toHaveBeenCalledWith('/labels/label-1');
      expect(result).toEqual(mockTemplateLabel);
      expect(result.id).toBe('label-1');
    });

    it('should handle label not found error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 404,
        data: { message: 'Label not found' },
        statusText: 'Not Found',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.get.mockRejectedValue(axiosError);

      await expect(labelsService.getLabelById('nonexistent')).rejects.toThrow();
    });

    it('should handle unauthorized access error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 401,
        data: { message: 'Unauthorized' },
        statusText: 'Unauthorized',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.get.mockRejectedValue(axiosError);

      await expect(labelsService.getLabelById('label-1')).rejects.toThrow();
    });
  });

  describe('generateLabelWithAI', () => {
    it('should generate AI label without container ID', async () => {
      const generateRequest: GenerateLabelRequest = {
        prompt: 'Create a minimalist floral label',
        name: 'AI Floral Label'
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockAILabel });

      const result = await labelsService.generateLabelWithAI(generateRequest);

      expect(mockAxiosInstance.post).toHaveBeenCalledWith('/labels/generate-ai', generateRequest);
      expect(result).toEqual(mockAILabel);
      expect(result.type).toBe('ai-generated');
      expect(result.aiPrompt).toBeDefined();
    });

    it('should generate AI label with container ID', async () => {
      const generateRequest: GenerateLabelRequest = {
        prompt: 'Create a vintage label for glass container'
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockAILabel });

      const result = await labelsService.generateLabelWithAI(generateRequest, 'container-1');

      expect(mockAxiosInstance.post).toHaveBeenCalledWith(
        '/labels/generate-ai?containerId=container-1',
        generateRequest
      );
      expect(result).toEqual(mockAILabel);
    });

    it('should handle AI generation error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 500,
        data: { message: 'AI service unavailable' },
        statusText: 'Internal Server Error',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.post.mockRejectedValue(axiosError);

      const generateRequest: GenerateLabelRequest = {
        prompt: 'Create a label'
      };

      await expect(labelsService.generateLabelWithAI(generateRequest)).rejects.toThrow();
    });

    it('should handle invalid prompt error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 400,
        data: { message: 'Prompt is too short' },
        statusText: 'Bad Request',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.post.mockRejectedValue(axiosError);

      const generateRequest: GenerateLabelRequest = {
        prompt: 'hi'
      };

      await expect(labelsService.generateLabelWithAI(generateRequest)).rejects.toThrow();
    });
  });

  describe('uploadCustomLabel', () => {
    it('should upload custom label without container ID', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockCustomLabel });

      const result = await labelsService.uploadCustomLabel(
        mockFile,
        'Custom Label',
        'A custom uploaded label'
      );

      expect(mockAxiosInstance.post).toHaveBeenCalledWith(
        '/labels/upload',
        expect.any(FormData),
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );
      expect(result).toEqual(mockCustomLabel);
    });

    it('should upload custom label with container ID', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockCustomLabel });

      const result = await labelsService.uploadCustomLabel(
        mockFile,
        'Custom Label',
        'A custom uploaded label',
        'container-1'
      );

      const callArgs = mockAxiosInstance.post.mock.calls[0];
      const formData = callArgs[1] as FormData;
      
      expect(mockAxiosInstance.post).toHaveBeenCalledWith(
        '/labels/upload',
        expect.any(FormData),
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );
      expect(result).toEqual(mockCustomLabel);
    });

    it('should upload custom label without description', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockCustomLabel });

      const result = await labelsService.uploadCustomLabel(
        mockFile,
        'Custom Label'
      );

      expect(mockAxiosInstance.post).toHaveBeenCalledWith(
        '/labels/upload',
        expect.any(FormData),
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );
      expect(result).toEqual(mockCustomLabel);
    });

    it('should handle file upload error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 413,
        data: { message: 'File too large' },
        statusText: 'Payload Too Large',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.post.mockRejectedValue(axiosError);

      await expect(
        labelsService.uploadCustomLabel(mockFile, 'Large File')
      ).rejects.toThrow();
    });

    it('should handle invalid file type error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 400,
        data: { message: 'Invalid file type' },
        statusText: 'Bad Request',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.post.mockRejectedValue(axiosError);

      await expect(
        labelsService.uploadCustomLabel(mockFile, 'Invalid File')
      ).rejects.toThrow();
    });
  });

  describe('createTemplateLabel', () => {
    it('should create template label successfully', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockTemplateLabel });

      const result = await labelsService.createTemplateLabel(
        mockFile,
        'New Template',
        'A new template label'
      );

      expect(mockAxiosInstance.post).toHaveBeenCalledWith(
        '/labels/upload-template',
        expect.any(FormData),
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );
      expect(result).toEqual(mockTemplateLabel);
      expect(result.type).toBe('template');
    });

    it('should create template label without description', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockTemplateLabel });

      const result = await labelsService.createTemplateLabel(
        mockFile,
        'New Template'
      );

      expect(mockAxiosInstance.post).toHaveBeenCalledWith(
        '/labels/upload-template',
        expect.any(FormData),
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );
      expect(result).toEqual(mockTemplateLabel);
    });

    it('should handle template creation error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 409,
        data: { message: 'Template with this name already exists' },
        statusText: 'Conflict',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.post.mockRejectedValue(axiosError);

      await expect(
        labelsService.createTemplateLabel(mockFile, 'Existing Template')
      ).rejects.toThrow();
    });

    it('should handle unauthorized template creation', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 403,
        data: { message: 'Forbidden - Admin access required' },
        statusText: 'Forbidden',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.post.mockRejectedValue(axiosError);

      await expect(
        labelsService.createTemplateLabel(mockFile, 'Admin Template')
      ).rejects.toThrow();
    });
  });

  describe('updateTemplateLabel', () => {
    it('should update template label with file', async () => {
      const updateData: Partial<Label> = {
        name: 'Updated Template',
        description: 'Updated description'
      };

      const updatedLabel = { ...mockTemplateLabel, ...updateData };
      mockAxiosInstance.patch.mockResolvedValue({ data: updatedLabel });

      const result = await labelsService.updateTemplateLabel('label-1', updateData, mockFile);

      expect(mockAxiosInstance.patch).toHaveBeenCalledWith(
        '/labels/label-1/with-file',
        expect.any(FormData),
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );
      expect(result).toEqual(updatedLabel);
    });

    it('should update template label without file', async () => {
      const updateData: Partial<Label> = {
        name: 'Updated Template',
        description: 'Updated description'
      };

      const updatedLabel = { ...mockTemplateLabel, ...updateData };
      mockAxiosInstance.patch.mockResolvedValue({ data: updatedLabel });

      const result = await labelsService.updateTemplateLabel('label-1', updateData);

      expect(mockAxiosInstance.patch).toHaveBeenCalledWith('/labels/label-1', updateData);
      expect(result).toEqual(updatedLabel);
    });

    it('should update template label with file but no description', async () => {
      const updateData: Partial<Label> = {
        name: 'Updated Template'
      };

      const updatedLabel = { ...mockTemplateLabel, ...updateData };
      mockAxiosInstance.patch.mockResolvedValue({ data: updatedLabel });

      const result = await labelsService.updateTemplateLabel('label-1', updateData, mockFile);

      expect(mockAxiosInstance.patch).toHaveBeenCalledWith(
        '/labels/label-1/with-file',
        expect.any(FormData),
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );
      expect(result).toEqual(updatedLabel);
    });

    it('should handle label not found error during update', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 404,
        data: { message: 'Label not found' },
        statusText: 'Not Found',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.patch.mockRejectedValue(axiosError);

      const updateData: Partial<Label> = { name: 'New Name' };

      await expect(
        labelsService.updateTemplateLabel('nonexistent', updateData)
      ).rejects.toThrow();
    });

    it('should handle forbidden update error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 403,
        data: { message: 'Forbidden' },
        statusText: 'Forbidden',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.patch.mockRejectedValue(axiosError);

      const updateData: Partial<Label> = { name: 'New Name' };

      await expect(
        labelsService.updateTemplateLabel('label-1', updateData)
      ).rejects.toThrow();
    });
  });

  describe('deleteLabel', () => {
    it('should delete label successfully', async () => {
      mockAxiosInstance.delete.mockResolvedValue({});

      await labelsService.deleteLabel('label-1');

      expect(mockAxiosInstance.delete).toHaveBeenCalledWith('/labels/label-1');
    });

    it('should handle label not found error during delete', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 404,
        data: { message: 'Label not found' },
        statusText: 'Not Found',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.delete.mockRejectedValue(axiosError);

      await expect(labelsService.deleteLabel('nonexistent')).rejects.toThrow();
    });

    it('should handle conflict error when deleting label in use', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 409,
        data: { message: 'Cannot delete label that is being used by candles' },
        statusText: 'Conflict',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.delete.mockRejectedValue(axiosError);

      await expect(labelsService.deleteLabel('label-1')).rejects.toThrow();
    });

    it('should handle unauthorized delete error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 401,
        data: { message: 'Unauthorized' },
        statusText: 'Unauthorized',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.delete.mockRejectedValue(axiosError);

      await expect(labelsService.deleteLabel('label-1')).rejects.toThrow();
    });
  });

  describe('Error Handling', () => {
    it('should handle timeout error', async () => {
      const timeoutError = new AxiosError('Request failed');
      timeoutError.code = 'ECONNABORTED';
      
      mockAxiosInstance.get.mockRejectedValue(timeoutError);

      await expect(labelsService.getAllLabels()).rejects.toThrow();
    });

    it('should handle connection error', async () => {
      const connectionError = new AxiosError('Request failed');
      connectionError.code = 'ENOTFOUND';
      
      mockAxiosInstance.get.mockRejectedValue(connectionError);

      await expect(labelsService.getAllLabels()).rejects.toThrow();
    });

    it('should handle gateway timeout error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 504,
        data: { message: 'Gateway timeout' },
        statusText: 'Gateway Timeout',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.get.mockRejectedValue(axiosError);

      await expect(labelsService.getAllLabels()).rejects.toThrow();
    });

    it('should handle bad gateway error', async () => {
      const axiosError = new AxiosError('Request failed');
      axiosError.response = {
        status: 502,
        data: { message: 'Bad gateway' },
        statusText: 'Bad Gateway',
        headers: {},
        config: {} as any
      };
      
      mockAxiosInstance.get.mockRejectedValue(axiosError);

      await expect(labelsService.getAllLabels()).rejects.toThrow();
    });
  });

  describe('Service Configuration', () => {

    it('should pass through errors from interceptor', async () => {
      const customError = new Error('Custom interceptor error');
      mockAxiosInstance.get.mockRejectedValue(customError);

      await expect(labelsService.getAllLabels()).rejects.toThrow('Custom interceptor error');
    });
  });

  describe('FormData Handling', () => {
    it('should properly construct FormData for file uploads', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockCustomLabel });

      await labelsService.uploadCustomLabel(
        mockFile,
        'Test Label',
        'Test Description',
        'container-1'
      );

      const callArgs = mockAxiosInstance.post.mock.calls[0];
      const formData = callArgs[1] as FormData;

      expect(formData).toBeInstanceOf(FormData);
      expect(callArgs[2]).toEqual({
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
    });

    it('should handle FormData construction for template creation', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockTemplateLabel });

      await labelsService.createTemplateLabel(
        mockFile,
        'Template Name',
        'Template Description'
      );

      const callArgs = mockAxiosInstance.post.mock.calls[0];
      const formData = callArgs[1] as FormData;

      expect(formData).toBeInstanceOf(FormData);
      expect(callArgs[0]).toBe('/labels/upload-template');
    });

    it('should handle FormData construction for updates with file', async () => {
      const updateData: Partial<Label> = {
        name: 'Updated Name',
        description: 'Updated Description'
      };

      mockAxiosInstance.patch.mockResolvedValue({ data: mockTemplateLabel });

      await labelsService.updateTemplateLabel('label-1', updateData, mockFile);

      const callArgs = mockAxiosInstance.patch.mock.calls[0];
      const formData = callArgs[1] as FormData;

      expect(formData).toBeInstanceOf(FormData);
      expect(callArgs[0]).toBe('/labels/label-1/with-file');
    });
  });

  describe('Data Processing', () => {
    it('should handle label with all optional fields', async () => {
      const fullLabel: Label = {
        id: 'label-full',
        name: 'Full Label',
        description: 'Complete label with all fields',
        imageUrl: 'https://example.com/full.jpg',
        type: 'custom',
        aiPrompt: 'AI prompt for generation',
        isActive: true,
        container: mockContainer,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z',
        isLocal: false,
        localPreview: undefined,
        localPrompt: undefined
      };

      mockAxiosInstance.get.mockResolvedValue({ data: fullLabel });

      const result = await labelsService.getLabelById('label-full');

      expect(result).toEqual(fullLabel);
      expect(result.container).toBeDefined();
      expect(result.aiPrompt).toBeDefined();
    });

    it('should handle label with minimal fields', async () => {
      const minimalLabel: Label = {
        id: 'label-minimal',
        name: 'Minimal Label',
        imageUrl: 'https://example.com/minimal.jpg',
        type: 'template',
        isActive: true,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z'
      };

      mockAxiosInstance.get.mockResolvedValue({ data: minimalLabel });

      const result = await labelsService.getLabelById('label-minimal');

      expect(result).toEqual(minimalLabel);
      expect(result.description).toBeUndefined();
      expect(result.container).toBeUndefined();
      expect(result.aiPrompt).toBeUndefined();
    });

    it('should handle local label with preview data', async () => {
      const result = mockLocalLabel;

      expect(result.isLocal).toBe(true);
      expect(result.localPreview).toBeDefined();
      expect(result.localPrompt).toBeDefined();
    });
  });

  describe('URL Construction', () => {
    it('should construct correct URL for AI generation without container', async () => {
      const generateRequest: GenerateLabelRequest = {
        prompt: 'Test prompt'
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockAILabel });

      await labelsService.generateLabelWithAI(generateRequest);

      expect(mockAxiosInstance.post).toHaveBeenCalledWith(
        '/labels/generate-ai',
        generateRequest
      );
    });

    it('should construct correct URL for AI generation with container', async () => {
      const generateRequest: GenerateLabelRequest = {
        prompt: 'Test prompt'
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockAILabel });

      await labelsService.generateLabelWithAI(generateRequest, 'container-123');

      expect(mockAxiosInstance.post).toHaveBeenCalledWith(
        '/labels/generate-ai?containerId=container-123',
        generateRequest
      );
    });
  });
});